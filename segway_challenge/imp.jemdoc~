# jemdoc: menu{MENU}{imp.html}, fwtitle
= Lego Segway Challenge: an introduction to embedded control

Our analysis so far has revealed a very simple way of controlling the inverted pendulum to balance around its upright equilibrium: we should simply generate a force which is prortional to the angular deviation and rate of deviation
\(
	T(t) = -k_p \theta(t)-k_d\dot{\theta}(t)
\)
This balancing act requires three essential steps
. Measuring, or /sensing/, the angle $\theta$ and the angular rate $\dot{\theta}$. 
. /Computing/ the desired control action $T(t)$
. Generating, or /actuating/, the required torque

This sensing-computing-actuating chain of operations, illustrated in the figure below, can be found in all control systems. The quality of the sensors, control algorithms and actuators all influence if, and how well, we can control a given physical object.  

\(
\setlength{\unitlength}{1mm}
\begin{picture}(110,50)
\put(15,35){\vector(1,0){10}}
\put(25,25){\framebox(20,20){\textrm{Sensors}}}
\put(45,35){\vector(1,0){10}}
\put(55,25){\framebox(20,20){\textrm{Computer}}}
\put(75,35){\vector(1,0){10}}
\put(85,25){\framebox(20,20){\textrm{Actuators}}}
\put(105,35){\vector(1,0){10}}
\end{picture}
\)

For the inverted pendulum, there are many possible ways of sensing the angle; many control algorithms that can stabilize the pendulum; and many ways of generating the appropriate torque. Let's go through some of our options before we start developing our physical system and control solution.

== Sensors 

The angle $\theta$ could be measured by digital encoders at its base, or be computed by integrating measurements of the rate-of-change $\dot{\theta}$. The angular rate-of-change $\dot{\theta}$, in turn, can be measured by a gyro sensor, or be computed by integrating a measurement of its acceleration. Finally, the acceleration $\ddot{\theta}$ can be measured by an accelerometer. Let's describe these solutions in some more detail.

=== Digital encoders
The motors in the LEGO mindstorm kit have built in encoders that give a digital value of the angle of the motors. Thus, if a motor is used to generate the required torque, it can also be used to give information about the angle at the base of the pendulum. 

=== Gyro sensor
A gyro sensor gives the rate of rotation $\dot{\theta}$. Here we are also using a {{<a href="http://www.hitechnic.com/contents/en-us/d24.html">HiTechnic Gyro Sensor </a>}} which can give the rotation of up to $\pm 360$ degrees per second. 

A problem with gyro sensors is that they have a little bit of offset, i.e. the gyro always shows a non-zero value even if the velocity is zero. This problem is more pronounced when we integrate the gyro readings to estimate the true angle, since the offset in the angle estimates will increase linearly with time. Thus, to give a proper velocity reading the gyro has to be calibrated. A common (and very simple) way of doing this is to compute the offset prior to operation and then subtracting this value from the gyro readings. The offset can be measured by keeping the gyro stable for a couple of seconds and averaging the readings. See below for the raw values, integration of these and the drift when not taken care of.

{{<img class="eq" src="Pic/drift.png" alt="Drift" style="vertical-align: -1px" width="800" />}}

=== Accelerometer/Tilt sensor

The {{<a href="http://www.hitechnic.com/contents/en-us/d19.html">accelerometer sensor </a>}} from HiTechnic can estimate the acceleration in $x$, $y$ and $z$ directions. The tilt could potentially be calculated by looking at how much the value of the gravitational acceleration differs from the measured acceleration in one direction. However, as shown below, the raw accelerometer reading is very noisy and must be filtered prior to use. 



=== Evaluating sensor quality 

The figure below shows angular measurement from a real pendulum. Each of the three sensor solutions have its own problems. The digital encoder is mesuring the angle at the base. Since the pendulum in this case is not completely stiff, the measurments get distorted each time the pendulum changes direction. 

The problem with the gyro solution is that since the angle estimate is obtained by integration and hence does not react to fast changes as quickly as the other sensors. But the positive side is that the sensor has high accuracy and very little noise.

As for the accelerometer, it reacts quickly to changes but is very noisy. 

{{<img class="eq" src="Pic/jamforelse.png" alt="Data" style="vertical-align: -1px" />}}


== Computing the control signal

All computations take place in the LEGO NXT embedded computer. The controller program will repeatedly read the sensors, compute the desired control signal, and command the motors to generate the required torque. We will devote a complete section to programming later in this tutorial, so let's skip this for now.

== Actuators 

The only actuators that we have at our command are the motors that come with the Mindstorm kit. The motors can be commanded to generate $\pm 100\%$  of maximum power. The power is assumed to be proportional to the torque by some unknown constant, which needs to be estimated or tuned by trial and error. 


== Programing Lego Mindstorm

Now that we know how what information we need we can start by looking at how to acquire it and how to use it. We want a way to process the information given by the sensors, calculate the desired output and aply it to the motors. Fortunatly Lego provides this functionality (and a lot more) in it Mindstorm unit.

The Mindstorm block can be programmed in a few completely different ways - from using the built in tool on the block, to using a low level language very similar to assembler. What will be used in this exampel is the programming language Not eXactly C (NXC). It is a language that is fast but still intuitive to people with only a small experience in programming. It is based on C with the addition of some extra commands to interface with the mindstorm unit. Assumed is basic programming skills.

=== Not eXactly C

There is a lot of resourses online covering exactly how to program C and NXC so there is no use trying to explain what other already have done better. Below is a list of resources that will be helpful when programming.

{{<a href="http://bricxcc.sourceforge.net/nbc/nxcdoc/index.html">Not eXactly C Documentation </a> <p>
<a href="http://www.hitechnic.com">HiTechnic Guides </a><p>
<a href="http://www.hitechnic.com/contents/en-us/d24.html">HiTechnic Gyro Sensor </a><p>
<a href="http://www.hitechnic.com/contents/en-us/d19.html">HiTechnic Acceleration Sensor </a>}}

=== Bricx Command Center

To be able to program in NXC you need a compiler. The easiest one to use is Bricx Command Center which also includes a GUI and debugger. See {{<a href="http://bricxcc.sourceforge.net/">BricxCC</a>}} for download and guides. When you have familiarized yourself with NXC and set up so that NXC is owrking on you Mindstorm unit, move on to the next section.

